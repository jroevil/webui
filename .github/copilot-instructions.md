<!--
Quick, focused instructions for AI coding agents working on this repo.
Keep this file concise and actionable — reference only discoverable patterns.
-->
# Copilot instructions for WebUI repository

Summary
- WebUI is a small C/C++ library that uses a tiny HTTP/WebSocket server (embedded CivetWeb) and a JavaScript "bridge" to drive real web browsers or platform WebViews as the GUI.

Essential architecture
- Backend (C/C++): [include/webui.h] and [src/webui.c] implement the public API and server logic.
- Embedded HTTP/WS server: [src/civetweb/] — the library embeds CivetWeb for serving UI assets and WebSocket transport.
- Frontend bridge: [bridge/webui.ts] -> bundled via `esbuild`, converted to C array by `js2c.py` to produce [bridge/webui_bridge.h], which is #included into `src/webui.c`.
- Platform WebView shims: [src/webview/] contains platform-specific adapters (Win32 WebView2, GTK/WebKit and macOS stubs).

Key developer workflows (what to run)
- Build the JS bridge (required whenever `bridge/webui.ts` changes):
  - Windows PowerShell: `cd bridge && build.bat` (requires `node` and `python`)
  - Linux/macOS: `cd bridge && ./build.sh`
  - Manual: `npm install esbuild && node_modules/.bin/esbuild --bundle --target="chrome90,firefox90,safari15" --format=esm --outdir=. ./webui.ts && python js2c.py`
- Build the native library/examples:
  - Linux/macOS: `make`
  - Windows (MinGW): `mingw32-make`
  - Windows (MSVC): `nmake` (see top-level README for linker flags and secure builds)

Important repo conventions and gotchas
- Do NOT hand-edit `bridge/webui_bridge.h`: it is generated by `bridge/js2c.py` from the bundled JS output. Always rebuild the bridge after JS changes.
- Feature flags are controlled by preprocessor macros: `WEBUI_USE_TLS` / `WEBUI_TLS_*` for TLS builds, `WEBUI_DYNAMIC` for shared vs static, `WEBUI_LOG` for verbose logs.
- Protocol is binary and versioned in C (`WEBUI_SIGNATURE`, command constants in `src/webui.c`) and mirrored in the JS bridge — cross-check both sides when changing protocol data.
- Single-header API: most consumers include `include/webui.h` (C) or `include/webui.hpp` (C++). Examples live in `examples/C` and `examples/C++` and are the best runtime tests.

Patterns to follow when changing code
- If you edit browser-facing behavior (JS), update bridge, run `build.bat`/`build.sh`, then build the native code so the generated C header is recompiled into the binary.
- Platform-specific code lives under `src/webview/`. Add shims there and avoid scattering platform checks across `webui.c`.
- For debugging native<->JS issues, enable `WEBUI_LOG` and search for tokens and command constants (`WEBUI_CMD_*`) in both `src/webui.c` and `bridge/webui.ts`.

Integration touchpoints
- bridge/webui.ts (source JS) -> esbuild -> generated JS -> js2c.py -> bridge/webui_bridge.h -> included into src/webui.c
- CivetWeb sources in `src/civetweb` are compiled into the library; edits there affect HTTP/WS behavior.

Where to run manual checks
- Run one of the examples after building, e.g. `examples/C/minimal/main.c` — they exercise the bridge and server.
- When changing TLS, ensure platform OpenSSL headers/libraries are available and follow the README TLS snippets.

If anything is unclear
- Ask for which file(s) you want more detail (JS bridge, protocol constants, or build flags) and I will expand this file accordingly.
